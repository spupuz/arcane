import type { VulnerabilityScanSummary } from '$lib/types/vulnerability.type';

export type VulnerabilityScanPollOptions = {
	intervalMs?: number;
	maxAttempts?: number;
	onUpdate?: (summary: VulnerabilityScanSummary) => void;
	onComplete?: (summary: VulnerabilityScanSummary) => void;
	onError?: (error: unknown) => void;
};

export type VulnerabilityScanTracker = {
	cancel: () => void;
	promise: Promise<VulnerabilityScanSummary>;
};

export function startVulnerabilityScanPolling(
	imageId: string,
	fetchSummary: (imageId: string) => Promise<VulnerabilityScanSummary>,
	options: VulnerabilityScanPollOptions = {}
): () => void {
	const { intervalMs = 2000, maxAttempts = 0, onUpdate, onComplete, onError } = options;
	let attempts = 0;
	let cancelled = false;
	let timeoutId: ReturnType<typeof setTimeout> | null = null;

	const schedule = () => {
		if (cancelled) return;
		timeoutId = setTimeout(run, intervalMs);
	};

	const run = async () => {
		if (cancelled) return;
		attempts += 1;
		try {
			const summary = await fetchSummary(imageId);
			onUpdate?.(summary);

			const isScanning = summary?.status === 'scanning' || summary?.status === 'pending';
			if (!isScanning) {
				onComplete?.(summary);
				return;
			}
		} catch (error) {
			onError?.(error);
		}

		if (maxAttempts > 0 && attempts >= maxAttempts) {
			onError?.(new Error('Scan polling exceeded max attempts.'));
			return;
		}

		schedule();
	};

	void run();

	return () => {
		cancelled = true;
		if (timeoutId) {
			clearTimeout(timeoutId);
		}
	};
}

export function startVulnerabilityScanTracking(
	imageId: string,
	fetchSummary: (imageId: string) => Promise<VulnerabilityScanSummary>,
	options: VulnerabilityScanPollOptions = {}
): VulnerabilityScanTracker {
	let resolvePromise: (summary: VulnerabilityScanSummary) => void;
	let rejectPromise: (error: unknown) => void;

	const promise = new Promise<VulnerabilityScanSummary>((resolve, reject) => {
		resolvePromise = resolve;
		rejectPromise = reject;
	});

	const cancel = startVulnerabilityScanPolling(imageId, fetchSummary, {
		...options,
		onComplete: (summary) => {
			options.onComplete?.(summary);
			if (summary.status === 'completed') {
				resolvePromise(summary);
			} else {
				rejectPromise(summary);
			}
		},
		onError: (error) => {
			options.onError?.(error);
			rejectPromise(error);
		}
	});

	return { cancel, promise };
}
