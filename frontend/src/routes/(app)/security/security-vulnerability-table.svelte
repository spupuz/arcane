<script lang="ts">
	import ArcaneTable from '$lib/components/arcane-table/arcane-table.svelte';
	import UniversalMobileCard from '$lib/components/arcane-table/cards/universal-mobile-card.svelte';
	import StatusBadge from '$lib/components/badges/status-badge.svelte';
	import { vulnerabilityService } from '$lib/services/vulnerability-service';
	import { m } from '$lib/paraglide/messages';
	import type { ColumnSpec } from '$lib/components/arcane-table/arcane-table.types.svelte';
	import type { Paginated, SearchPaginationSortRequest } from '$lib/types/pagination.type';
	import type { VulnerabilityWithImage } from '$lib/types/vulnerability.type';
	import { ShieldAlertIcon, CodeIcon, CheckIcon, ImagesIcon, EyeOffIcon } from '$lib/icons';
	import { toast } from 'svelte-sonner';
	import type { BulkAction } from '$lib/components/arcane-table/arcane-table.types.svelte';

	const DEFAULT_PAGE_SIZE = 20;

	type VulnerabilityRow = VulnerabilityWithImage & { id: string };

	let {
		vulnerabilities = $bindable(),
		requestOptions = $bindable()
	}: {
		vulnerabilities: Paginated<VulnerabilityRow>;
		requestOptions: SearchPaginationSortRequest;
	} = $props();

	function getSeverityLabel(severity: string): string {
		switch (severity) {
			case 'CRITICAL':
				return m.vuln_severity_critical();
			case 'HIGH':
				return m.vuln_severity_high();
			case 'MEDIUM':
				return m.vuln_severity_medium();
			case 'LOW':
				return m.vuln_severity_low();
			default:
				return m.vuln_severity_unknown();
		}
	}

	function getSeverityBadgeVariant(severity: string): 'red' | 'orange' | 'amber' | 'green' | 'gray' {
		switch (severity) {
			case 'CRITICAL':
				return 'red';
			case 'HIGH':
				return 'orange';
			case 'MEDIUM':
				return 'amber';
			case 'LOW':
				return 'green';
			default:
				return 'gray';
		}
	}

	function getSeverityIconVariant(severity: string): 'red' | 'orange' | 'amber' | 'emerald' | 'gray' {
		switch (severity) {
			case 'CRITICAL':
				return 'red';
			case 'HIGH':
				return 'orange';
			case 'MEDIUM':
				return 'amber';
			case 'LOW':
				return 'emerald';
			default:
				return 'gray';
		}
	}

	function getVulnerabilityKey(vuln: VulnerabilityWithImage, index: number): string {
		return [
			vuln.imageId,
			vuln.vulnerabilityId,
			vuln.pkgName,
			vuln.installedVersion ?? '',
			vuln.fixedVersion ?? '',
			String(index)
		].join('-');
	}

	async function refreshVulnerabilityTable(options: SearchPaginationSortRequest) {
		const mergedFilters = { ...(options.filters ?? {}) };
		if (mergedFilters.vulnSeverity) {
			mergedFilters.severity = mergedFilters.vulnSeverity;
			delete mergedFilters.vulnSeverity;
		}

		const sort = options.sort?.column === 'vulnSeverity' ? { ...options.sort, column: 'severity' } : options.sort;

		const request: SearchPaginationSortRequest = {
			...options,
			sort,
			filters: Object.keys(mergedFilters).length ? mergedFilters : undefined
		};

		const response = await vulnerabilityService.getAllVulnerabilities(request);
		const page = request.pagination?.page ?? 1;
		const limit = request.pagination?.limit ?? DEFAULT_PAGE_SIZE;
		const offset = (page - 1) * limit;
		const mapped: Paginated<VulnerabilityRow> = {
			...response,
			data: (response.data ?? []).map((item, index) => ({
				...item,
				id: getVulnerabilityKey(item, offset + index)
			}))
		};
		vulnerabilities = mapped;
		return mapped;
	}

	async function handleIgnoreVulnerability(item: VulnerabilityRow) {
		console.log('Ignoring vulnerability:', {
			imageId: item.imageId,
			vulnerabilityId: item.vulnerabilityId,
			pkgName: item.pkgName,
			installedVersion: item.installedVersion
		});
		try {
			const payload = {
				imageId: item.imageId || '',
				vulnerabilityId: item.vulnerabilityId || '',
				pkgName: item.pkgName || '',
				installedVersion: item.installedVersion || ''
			};
			console.log('Sending payload:', payload);
			await vulnerabilityService.ignoreVulnerability(payload);
			toast.success(m.vuln_ignore_success({ cve: item.vulnerabilityId }));
			// Refresh the table to remove the ignored vulnerability
			await refreshVulnerabilityTable(requestOptions);
		} catch (error) {
			console.error('Failed to ignore vulnerability:', error);
			toast.error(m.vuln_ignore_failed());
		}
	}

	const columns = $derived([
		{ accessorKey: 'vulnerabilityId', title: 'CVE', cell: CveCell },
		{ accessorKey: 'pkgName', title: m.vuln_package(), cell: PackageCell },
		{ id: 'vulnSeverity', accessorKey: 'severity', title: m.events_col_severity(), sortable: true, cell: SeverityCell },
		{ accessorKey: 'installedVersion', title: m.vuln_installed_version(), cell: InstalledCell },
		{ accessorKey: 'fixedVersion', title: m.vuln_fixed_version(), cell: FixedCell },
		{ accessorKey: 'imageName', title: m.common_image(), sortable: true, cell: ImageCell }
	] satisfies ColumnSpec<VulnerabilityRow>[]);

	const uniqueImageNames = $derived(
		[...new Set((vulnerabilities.data ?? []).map((r) => r.imageName || r.imageId).filter(Boolean) as string[])].sort()
	);

	const mobileFields = [
		{ id: 'vulnerabilityId', label: 'CVE', defaultVisible: true },
		{ id: 'pkgName', label: m.vuln_package(), defaultVisible: true },
		{ id: 'vulnSeverity', label: m.events_col_severity(), defaultVisible: true },
		{ id: 'imageName', label: m.common_image(), defaultVisible: true },
		{ id: 'installedVersion', label: m.vuln_installed_version(), defaultVisible: false },
		{ id: 'fixedVersion', label: m.vuln_fixed_version(), defaultVisible: false }
	];
</script>

{#snippet CveCell({ item }: { item: VulnerabilityRow })}
	<a
		href="https://nvd.nist.gov/vuln/detail/{item.vulnerabilityId}"
		target="_blank"
		rel="noopener noreferrer"
		class="font-mono text-xs text-blue-600 hover:underline dark:text-blue-400"
	>
		{item.vulnerabilityId}
	</a>
{/snippet}

{#snippet PackageCell({ item }: { item: VulnerabilityRow })}
	<span class="font-mono text-xs">{item.pkgName}</span>
{/snippet}

{#snippet SeverityCell({ item }: { item: VulnerabilityRow })}
	{#if item.severity === 'CRITICAL'}
		<StatusBadge text={m.vuln_severity_critical()} variant="red" size="sm" />
	{:else if item.severity === 'HIGH'}
		<StatusBadge text={m.vuln_severity_high()} variant="orange" size="sm" />
	{:else if item.severity === 'MEDIUM'}
		<StatusBadge text={m.vuln_severity_medium()} variant="amber" size="sm" />
	{:else if item.severity === 'LOW'}
		<StatusBadge text={m.vuln_severity_low()} variant="lime" size="sm" />
	{:else}
		<StatusBadge text={m.vuln_severity_unknown()} variant="gray" size="sm" />
	{/if}
{/snippet}

{#snippet InstalledCell({ item }: { item: VulnerabilityRow })}
	<span class="font-mono text-xs">{item.installedVersion}</span>
{/snippet}

{#snippet FixedCell({ item }: { item: VulnerabilityRow })}
	<span class="font-mono text-xs">{item.fixedVersion || m.vuln_no_fix()}</span>
{/snippet}

{#snippet ImageCell({ item }: { item: VulnerabilityRow })}
	<a class="truncate text-sm font-medium hover:underline" href="/images/{item.imageId}">
		{item.imageName || item.imageId}
	</a>
{/snippet}

{#snippet VulnerabilityMobileCard({
	row,
	item,
	mobileFieldVisibility
}: {
	row: any;
	item: VulnerabilityRow;
	mobileFieldVisibility: Record<string, boolean>;
})}
	<UniversalMobileCard
		{item}
		icon={(item) => ({
			component: ShieldAlertIcon,
			variant: getSeverityIconVariant(item.severity)
		})}
		title={(item) => item.vulnerabilityId}
		subtitle={(item) => ((mobileFieldVisibility.pkgName ?? true) ? item.pkgName : null)}
		badges={[
			(item) =>
				(mobileFieldVisibility.vulnSeverity ?? true)
					? { variant: getSeverityBadgeVariant(item.severity), text: getSeverityLabel(item.severity) }
					: null
		]}
		fields={[
			{
				label: m.common_image(),
				getValue: (item) => item.imageName || item.imageId,
				icon: ImagesIcon,
				iconVariant: 'gray',
				show: mobileFieldVisibility.imageName ?? true
			},
			{
				label: m.vuln_installed_version(),
				getValue: (item) => item.installedVersion,
				type: 'mono',
				icon: CodeIcon,
				iconVariant: 'blue',
				show: mobileFieldVisibility.installedVersion ?? true
			},
			{
				label: m.vuln_fixed_version(),
				getValue: (item) => item.fixedVersion || m.vuln_no_fix(),
				type: 'mono',
				icon: CheckIcon,
				iconVariant: item.fixedVersion ? 'emerald' : 'gray',
				show: mobileFieldVisibility.fixedVersion ?? true
			}
		]}
	/>
{/snippet}

{#snippet rowActions({ item }: { item: VulnerabilityRow })}
	<button
		onclick={() => handleIgnoreVulnerability(item)}
		class="text-muted-foreground hover:text-foreground inline-flex items-center gap-1 text-xs transition-colors"
		title={m.vuln_ignore()}
	>
		<EyeOffIcon class="h-3.5 w-3.5" />
		<span class="sr-only">{m.vuln_ignore()}</span>
	</button>
{/snippet}

<ArcaneTable
	items={vulnerabilities}
	bind:requestOptions
	onRefresh={refreshVulnerabilityTable}
	{columns}
	mobileCard={VulnerabilityMobileCard}
	{mobileFields}
	persistKey="arcane-security-vuln-table"
	selectionDisabled
	imageNameFilterOptions={uniqueImageNames}
	{rowActions}
/>
