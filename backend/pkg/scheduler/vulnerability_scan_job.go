package scheduler

import (
	"context"
	"fmt"
	"log/slog"
	"strconv"

	"github.com/getarcaneapp/arcane/backend/internal/models"
	"github.com/getarcaneapp/arcane/backend/internal/services"
	"github.com/getarcaneapp/arcane/types"
	"github.com/robfig/cron/v3"
)

const VulnerabilityScanJobName = "vulnerability-scan"

// systemUser is used as the actor for scheduled vulnerability scans.
var vulnerabilityScanSystemUser = models.User{
	Username: "System",
}

// VulnerabilityScanJob periodically scans all Docker images for vulnerabilities
// using Trivy. It is opt-in via the "vulnerabilityScanEnabled" setting.
type VulnerabilityScanJob struct {
	vulnerabilityService *services.VulnerabilityService
	settingsService      *services.SettingsService
}

// NewVulnerabilityScanJob creates a new VulnerabilityScanJob.
func NewVulnerabilityScanJob(vulnerabilityService *services.VulnerabilityService, settingsService *services.SettingsService) *VulnerabilityScanJob {
	return &VulnerabilityScanJob{
		vulnerabilityService: vulnerabilityService,
		settingsService:      settingsService,
	}
}

func (j *VulnerabilityScanJob) Name() string {
	return VulnerabilityScanJobName
}

// Schedule returns the cron expression for the job. Defaults to daily at midnight.
func (j *VulnerabilityScanJob) Schedule(ctx context.Context) string {
	schedule := j.settingsService.GetStringSetting(ctx, "vulnerabilityScanInterval", "0 0 0 * * *")
	if schedule == "" {
		schedule = "0 0 0 * * *"
	}

	// Handle legacy straight int if it somehow didn't get migrated
	if i, err := strconv.Atoi(schedule); err == nil {
		if i <= 0 {
			i = 1440
		}
		switch {
		case i%1440 == 0:
			schedule = fmt.Sprintf("0 0 0 */%d * *", i/1440)
		case i%60 == 0:
			schedule = fmt.Sprintf("0 0 */%d * * *", i/60)
		default:
			schedule = fmt.Sprintf("0 */%d * * * *", i)
		}
	}

	parser := cron.NewParser(cron.Second | cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow)
	if _, err := parser.Parse(schedule); err != nil {
		slog.WarnContext(ctx, "Invalid cron expression for vulnerability-scan, using default", "invalid_schedule", schedule, "error", err)
		return "0 0 0 * * *"
	}

	return schedule
}

func (j *VulnerabilityScanJob) Run(ctx context.Context) {
	enabled := j.settingsService.GetBoolSetting(ctx, "vulnerabilityScanEnabled", false)
	if !enabled {
		slog.DebugContext(ctx, "scheduled vulnerability scan disabled; skipping run")
		return
	}

	slog.InfoContext(ctx, "scheduled vulnerability scan started")

	// Remove scan records for images that no longer exist (fixes e.g. "5/3 images scanned").
	deleted, err := j.vulnerabilityService.CleanupOrphanedScanRecords(ctx)
	if err != nil {
		slog.WarnContext(ctx, "orphaned vulnerability scan cleanup failed", "error", err)
	}
	if deleted > 0 {
		slog.InfoContext(ctx, "cleaned up orphaned vulnerability scan records", "deleted", deleted)
	}

	scanned, failed, err := j.vulnerabilityService.ScanAllImages(ctx, types.LOCAL_DOCKER_ENVIRONMENT_ID, vulnerabilityScanSystemUser)
	if err != nil {
		slog.ErrorContext(ctx, "scheduled vulnerability scan failed", "error", err)
		return
	}

	slog.InfoContext(ctx, "scheduled vulnerability scan completed",
		"scanned", scanned,
		"failed", failed,
	)
}
