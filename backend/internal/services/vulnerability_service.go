package services

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"os"
	"strings"
	"sync"
	"time"

	containertypes "github.com/docker/docker/api/types/container"
	imagetypes "github.com/docker/docker/api/types/image"
	mounttypes "github.com/docker/docker/api/types/mount"
	volumetypes "github.com/docker/docker/api/types/volume"
	"github.com/docker/docker/client"
	"github.com/docker/docker/pkg/stdcopy"
	"github.com/getarcaneapp/arcane/backend/internal/database"
	"github.com/getarcaneapp/arcane/backend/internal/models"
	"github.com/getarcaneapp/arcane/backend/internal/utils/pagination"
	"github.com/getarcaneapp/arcane/backend/internal/utils/timeouts"
	"github.com/getarcaneapp/arcane/backend/pkg/libarcane"
	"github.com/getarcaneapp/arcane/types/vulnerability"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

const (
	DefaultTrivyImage     = "ghcr.io/aquasecurity/trivy:latest"
	trivyCacheVolumeName  = "arcane-trivy-cache"
	trivyCacheMountTarget = "/root/.cache"
	scanStaleTimeout      = 30 * time.Minute
	trivyMaxCPUNano       = int64(1_000_000_000) // 1 CPU core
	trivyMaxMemoryBytes   = int64(512 * 1024 * 1024)
)

// VulnerabilityService handles vulnerability scanning of container images
type VulnerabilityService struct {
	db                  *database.DB
	dockerService       *DockerClientService
	eventService        *EventService
	settingsService     *SettingsService
	notificationService *NotificationService
	// scanLocks provides per-image locking to allow concurrent scans of different images
	// while preventing duplicate scans of the same image
	scanLocks sync.Map // map[string]*sync.Mutex
}

// getImageLock returns a mutex for the given image ID, creating one if needed
func (s *VulnerabilityService) getImageLock(imageID string) *sync.Mutex {
	lock, _ := s.scanLocks.LoadOrStore(imageID, &sync.Mutex{})
	return lock.(*sync.Mutex)
}

// NewVulnerabilityService creates a new VulnerabilityService instance
func NewVulnerabilityService(db *database.DB, dockerService *DockerClientService, eventService *EventService, settingsService *SettingsService, notificationService *NotificationService) *VulnerabilityService {
	return &VulnerabilityService{
		db:                  db,
		dockerService:       dockerService,
		eventService:        eventService,
		settingsService:     settingsService,
		notificationService: notificationService,
	}
}

// ScanImage scans an image for vulnerabilities using Trivy
func (s *VulnerabilityService) ScanImage(ctx context.Context, envID string, imageID string, user models.User) (*vulnerability.ScanResult, error) {
	scanCtx := context.WithoutCancel(ctx)

	// Get Docker client to inspect the image
	dockerClient, err := s.dockerService.GetClient()
	if err != nil {
		return nil, fmt.Errorf("failed to connect to Docker: %w", err)
	}

	// Inspect the image to get details
	imageInspect, err := dockerClient.ImageInspect(scanCtx, imageID)
	if err != nil {
		return nil, fmt.Errorf("failed to inspect image: %w", err)
	}

	// Determine image name to scan
	imageName := imageID
	if len(imageInspect.RepoTags) > 0 {
		imageName = imageInspect.RepoTags[0]
	} else if len(imageInspect.RepoDigests) > 0 {
		imageName = imageInspect.RepoDigests[0]
	}

	// Create pending scan record
	pendingResult := &vulnerability.ScanResult{
		ImageID:   imageID,
		ImageName: imageName,
		ScanTime:  time.Now(),
		Status:    vulnerability.ScanStatusScanning,
	}
	if saveErr := s.saveScanResult(scanCtx, pendingResult); saveErr != nil {
		slog.WarnContext(scanCtx, "failed to save pending scan result", "error", saveErr)
	}

	go func(bgCtx context.Context, scanEnvID, imgID, imgName string, scanUser models.User) {
		s.scanImageInBackgroundInternal(bgCtx, scanEnvID, imgID, imgName, scanUser)
	}(scanCtx, envID, imageID, imageName, user)

	return pendingResult, nil
}

func (s *VulnerabilityService) markStaleScanIfNeeded(ctx context.Context, record *models.VulnerabilityScanRecord) bool {
	if record == nil {
		return false
	}
	if record.Status != models.ScanStatusScanning && record.Status != models.ScanStatusPending {
		return false
	}
	if time.Since(record.ScanTime) <= scanStaleTimeout {
		return false
	}

	errMsg := "Scan timed out or was interrupted. Please retry."
	record.Status = models.ScanStatusFailed
	record.Error = &errMsg
	record.Duration = time.Since(record.ScanTime).Milliseconds()

	if s.db == nil {
		return true
	}

	if err := s.db.WithContext(ctx).
		Model(&models.VulnerabilityScanRecord{}).
		Where("id = ?", record.ID).
		Updates(map[string]any{
			"status":   record.Status,
			"error":    errMsg,
			"duration": record.Duration,
		}).Error; err != nil {
		slog.WarnContext(ctx, "failed to mark stale scan as failed", "error", err, "scan_id", record.ID)
		return false
	}

	return true
}

func (s *VulnerabilityService) scanImageInBackgroundInternal(ctx context.Context, envID string, imageID, imageName string, user models.User) {
	trivyImage, err := s.ensureTrivyImageInternal(ctx)
	if err != nil {
		result := &vulnerability.ScanResult{
			ImageID:   imageID,
			ImageName: imageName,
			ScanTime:  time.Now(),
			Status:    vulnerability.ScanStatusFailed,
			Error:     fmt.Sprintf("Trivy scanner is not available: %s", err.Error()),
		}
		if saveErr := s.saveScanResult(ctx, result); saveErr != nil {
			slog.WarnContext(ctx, "failed to save scan result", "error", saveErr)
		}
		return
	}

	startTime := time.Now()
	result, err := s.runTrivyScan(ctx, trivyImage, imageName, imageID)
	duration := time.Since(startTime).Milliseconds()

	if err != nil {
		failedResult := &vulnerability.ScanResult{
			ImageID:   imageID,
			ImageName: imageName,
			ScanTime:  time.Now(),
			Status:    vulnerability.ScanStatusFailed,
			Error:     err.Error(),
			Duration:  duration,
		}
		if saveErr := s.saveScanResult(ctx, failedResult); saveErr != nil {
			slog.WarnContext(ctx, "failed to save failed scan result", "error", saveErr)
		}
		s.logScanEvent(ctx, envID, imageID, imageName, user, false, err.Error())
		return
	}

	result.Duration = duration
	s.ensureSummary(result)
	if saveErr := s.saveScanResult(ctx, result); saveErr != nil {
		slog.WarnContext(ctx, "failed to save scan result", "error", saveErr)
	}

	s.notifyVulnerabilitiesWithFix(ctx, result)
	s.logScanEvent(ctx, envID, imageID, imageName, user, true, "")
}

// GetScanResult retrieves the most recent scan result for an image
func (s *VulnerabilityService) GetScanResult(ctx context.Context, imageID string) (*vulnerability.ScanResult, error) {
	if s.db == nil {
		return nil, nil
	}

	var record models.VulnerabilityScanRecord
	err := s.db.WithContext(ctx).Where("id = ?", imageID).First(&record).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to get scan result: %w", err)
	}

	s.markStaleScanIfNeeded(ctx, &record)

	return s.convertRecordToResult(&record)
}

// GetScanSummary retrieves just the summary for an image (for list views)
func (s *VulnerabilityService) GetScanSummary(ctx context.Context, imageID string) (*vulnerability.ScanSummary, error) {
	if s.db == nil {
		return nil, nil
	}

	var record models.VulnerabilityScanRecord
	err := s.db.WithContext(ctx).
		Select("id", "scan_time", "status", "critical_count", "high_count", "medium_count", "low_count", "unknown_count", "total_count", "error").
		Where("id = ?", imageID).
		First(&record).Error

	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to get scan summary: %w", err)
	}

	s.markStaleScanIfNeeded(ctx, &record)

	var errPtr *string
	if record.Error != nil {
		errPtr = record.Error
	}

	return &vulnerability.ScanSummary{
		ImageID:  record.ID,
		ScanTime: record.ScanTime,
		Status:   vulnerability.ScanStatus(record.Status),
		Summary: &vulnerability.SeveritySummary{
			Critical: record.CriticalCount,
			High:     record.HighCount,
			Medium:   record.MediumCount,
			Low:      record.LowCount,
			Unknown:  record.UnknownCount,
			Total:    record.TotalCount,
		},
		Error: stringPtrValueOrEmptyInternal(errPtr),
	}, nil
}

// ListVulnerabilities returns a paginated, filtered list of vulnerabilities for an image.
func (s *VulnerabilityService) ListVulnerabilities(ctx context.Context, imageID string, params pagination.QueryParams) ([]vulnerability.Vulnerability, pagination.Response, error) {
	result, err := s.GetScanResult(ctx, imageID)
	if err != nil {
		return nil, pagination.Response{}, fmt.Errorf("failed to get scan result: %w", err)
	}
	if result == nil {
		limit := params.Limit
		if limit <= 0 {
			limit = 20
		}
		return []vulnerability.Vulnerability{}, pagination.Response{
			TotalPages:      1,
			TotalItems:      0,
			CurrentPage:     1,
			ItemsPerPage:    limit,
			GrandTotalItems: 0,
		}, nil
	}

	config := pagination.Config[vulnerability.Vulnerability]{
		SearchAccessors: []pagination.SearchAccessor[vulnerability.Vulnerability]{
			func(item vulnerability.Vulnerability) (string, error) { return item.VulnerabilityID, nil },
			func(item vulnerability.Vulnerability) (string, error) { return item.PkgName, nil },
			func(item vulnerability.Vulnerability) (string, error) { return item.InstalledVersion, nil },
			func(item vulnerability.Vulnerability) (string, error) { return item.FixedVersion, nil },
			func(item vulnerability.Vulnerability) (string, error) { return item.Title, nil },
		},
		SortBindings: []pagination.SortBinding[vulnerability.Vulnerability]{
			{
				Key: "vulnerabilityId",
				Fn: func(a, b vulnerability.Vulnerability) int {
					return strings.Compare(a.VulnerabilityID, b.VulnerabilityID)
				},
			},
			{
				Key: "pkgName",
				Fn:  func(a, b vulnerability.Vulnerability) int { return strings.Compare(a.PkgName, b.PkgName) },
			},
			{
				Key: "severity",
				Fn: func(a, b vulnerability.Vulnerability) int {
					return severityRankInternal(a.Severity) - severityRankInternal(b.Severity)
				},
			},
			{
				Key: "installedVersion",
				Fn: func(a, b vulnerability.Vulnerability) int {
					return strings.Compare(a.InstalledVersion, b.InstalledVersion)
				},
			},
			{
				Key: "fixedVersion",
				Fn:  func(a, b vulnerability.Vulnerability) int { return strings.Compare(a.FixedVersion, b.FixedVersion) },
			},
		},
		FilterAccessors: []pagination.FilterAccessor[vulnerability.Vulnerability]{
			{
				Key: "severity",
				Fn: func(item vulnerability.Vulnerability, value string) bool {
					return strings.EqualFold(string(item.Severity), value)
				},
			},
		},
	}

	filtered := pagination.SearchOrderAndPaginate(result.Vulnerabilities, params, config)
	response := pagination.BuildResponseFromFilterResult(filtered, params)

	return filtered.Items, response, nil
}

// GetEnvironmentSummary returns aggregated vulnerability counts across all images.
func (s *VulnerabilityService) GetEnvironmentSummary(ctx context.Context) (*vulnerability.EnvironmentVulnerabilitySummary, error) {
	if s.db != nil && s.dockerService != nil {
		if deleted, err := s.CleanupOrphanedScanRecords(ctx); err != nil {
			slog.WarnContext(ctx, "failed to cleanup orphaned vulnerability scan records", "error", err)
		} else if deleted > 0 {
			slog.DebugContext(ctx, "cleaned up orphaned vulnerability scan records", "deleted", deleted)
		}
	}

	summary := &vulnerability.EnvironmentVulnerabilitySummary{
		Summary: &vulnerability.SeveritySummary{},
	}

	if s.dockerService != nil {
		_, _, _, total, err := s.dockerService.GetAllImages(ctx)
		if err != nil {
			slog.WarnContext(ctx, "failed to list images for vulnerability summary", "error", err)
		} else {
			summary.TotalImages = total
		}
	}

	if s.db == nil {
		return summary, nil
	}

	type aggregate struct {
		Critical int `gorm:"column:critical"`
		High     int `gorm:"column:high"`
		Medium   int `gorm:"column:medium"`
		Low      int `gorm:"column:low"`
		Unknown  int `gorm:"column:unknown"`
		Total    int `gorm:"column:total"`
		Scanned  int `gorm:"column:scanned"`
	}

	var agg aggregate
	err := s.db.WithContext(ctx).
		Model(&models.VulnerabilityScanRecord{}).
		Select(
			"COALESCE(SUM(critical_count), 0) AS critical",
			"COALESCE(SUM(high_count), 0) AS high",
			"COALESCE(SUM(medium_count), 0) AS medium",
			"COALESCE(SUM(low_count), 0) AS low",
			"COALESCE(SUM(unknown_count), 0) AS unknown",
			"COALESCE(SUM(total_count), 0) AS total",
			"COUNT(*) AS scanned",
		).
		Where("status = ?", models.ScanStatusCompleted).
		Scan(&agg).Error
	if err != nil {
		return nil, fmt.Errorf("failed to aggregate vulnerability summary: %w", err)
	}

	summary.ScannedImages = agg.Scanned
	summary.Summary = &vulnerability.SeveritySummary{
		Critical: agg.Critical,
		High:     agg.High,
		Medium:   agg.Medium,
		Low:      agg.Low,
		Unknown:  agg.Unknown,
		Total:    agg.Total,
	}

	return summary, nil
}

// ListAllVulnerabilities returns a paginated list of vulnerabilities across all scanned images.
func (s *VulnerabilityService) ListAllVulnerabilities(ctx context.Context, envID string, params pagination.QueryParams) ([]vulnerability.VulnerabilityWithImage, pagination.Response, error) {
	if params.Limit == 0 {
		params.Limit = 20
	}

	if s.db == nil {
		return []vulnerability.VulnerabilityWithImage{}, pagination.Response{
			TotalPages:      1,
			TotalItems:      0,
			CurrentPage:     1,
			ItemsPerPage:    params.Limit,
			GrandTotalItems: 0,
		}, nil
	}

	var records []models.VulnerabilityScanRecord
	if err := s.db.WithContext(ctx).
		Select("id", "image_name", "vulnerabilities", "status", "total_count").
		Where("status = ?", models.ScanStatusCompleted).
		Where("total_count > 0").
		Find(&records).Error; err != nil {
		return nil, pagination.Response{}, fmt.Errorf("failed to list vulnerability scans: %w", err)
	}

	items := make([]vulnerability.VulnerabilityWithImage, 0)
	for _, record := range records {
		if len(record.Vulnerabilities) == 0 || record.Vulnerabilities[0] == "" {
			continue
		}

		var vulns []vulnerability.Vulnerability
		if err := json.Unmarshal([]byte(record.Vulnerabilities[0]), &vulns); err != nil {
			slog.WarnContext(ctx, "failed to unmarshal vulnerabilities", "error", err, "image_id", record.ID)
			continue
		}

		for _, vuln := range vulns {
			items = append(items, vulnerability.VulnerabilityWithImage{
				Vulnerability: vuln,
				ImageID:       record.ID,
				ImageName:     record.ImageName,
			})
		}
	}

	// Filter out ignored vulnerabilities
	items, err := s.filterIgnoredVulnerabilities(ctx, envID, items)
	if err != nil {
		slog.WarnContext(ctx, "failed to filter ignored vulnerabilities", "error", err)
	}

	config := pagination.Config[vulnerability.VulnerabilityWithImage]{
		SearchAccessors: []pagination.SearchAccessor[vulnerability.VulnerabilityWithImage]{
			func(item vulnerability.VulnerabilityWithImage) (string, error) { return item.VulnerabilityID, nil },
			func(item vulnerability.VulnerabilityWithImage) (string, error) { return item.PkgName, nil },
			func(item vulnerability.VulnerabilityWithImage) (string, error) { return item.InstalledVersion, nil },
			func(item vulnerability.VulnerabilityWithImage) (string, error) { return item.FixedVersion, nil },
			func(item vulnerability.VulnerabilityWithImage) (string, error) { return item.Title, nil },
			func(item vulnerability.VulnerabilityWithImage) (string, error) { return item.ImageName, nil },
			func(item vulnerability.VulnerabilityWithImage) (string, error) { return item.ImageID, nil },
		},
		SortBindings: []pagination.SortBinding[vulnerability.VulnerabilityWithImage]{
			{
				Key: "vulnerabilityId",
				Fn: func(a, b vulnerability.VulnerabilityWithImage) int {
					return strings.Compare(a.VulnerabilityID, b.VulnerabilityID)
				},
			},
			{
				Key: "pkgName",
				Fn:  func(a, b vulnerability.VulnerabilityWithImage) int { return strings.Compare(a.PkgName, b.PkgName) },
			},
			{
				Key: "severity",
				Fn: func(a, b vulnerability.VulnerabilityWithImage) int {
					return severityRankInternal(a.Severity) - severityRankInternal(b.Severity)
				},
			},
			{
				Key: "installedVersion",
				Fn: func(a, b vulnerability.VulnerabilityWithImage) int {
					return strings.Compare(a.InstalledVersion, b.InstalledVersion)
				},
			},
			{
				Key: "fixedVersion",
				Fn: func(a, b vulnerability.VulnerabilityWithImage) int {
					return strings.Compare(a.FixedVersion, b.FixedVersion)
				},
			},
			{
				Key: "imageName",
				Fn:  func(a, b vulnerability.VulnerabilityWithImage) int { return strings.Compare(a.ImageName, b.ImageName) },
			},
		},
		FilterAccessors: []pagination.FilterAccessor[vulnerability.VulnerabilityWithImage]{
			{
				Key: "severity",
				Fn: func(item vulnerability.VulnerabilityWithImage, value string) bool {
					return strings.EqualFold(string(item.Severity), value)
				},
			},
			{
				Key: "imageName",
				Fn: func(item vulnerability.VulnerabilityWithImage, value string) bool {
					itemLower := strings.ToLower(item.ImageName)
					for _, part := range strings.Split(value, ",") {
						if part = strings.TrimSpace(part); part != "" && strings.Contains(itemLower, strings.ToLower(part)) {
							return true
						}
					}
					return false
				},
			},
		},
	}

	filtered := pagination.SearchOrderAndPaginate(items, params, config)
	response := pagination.BuildResponseFromFilterResult(filtered, params)

	return filtered.Items, response, nil
}

func severityRankInternal(severity vulnerability.Severity) int {
	switch severity {
	case vulnerability.SeverityCritical:
		return 4
	case vulnerability.SeverityHigh:
		return 3
	case vulnerability.SeverityMedium:
		return 2
	case vulnerability.SeverityLow:
		return 1
	case vulnerability.SeverityUnknown:
		return 0
	default:
		return 0
	}
}

// GetScanSummariesByImageIDs retrieves scan summaries for multiple images
func (s *VulnerabilityService) GetScanSummariesByImageIDs(ctx context.Context, imageIDs []string) (map[string]*vulnerability.ScanSummary, error) {
	if s.db == nil || len(imageIDs) == 0 {
		return make(map[string]*vulnerability.ScanSummary), nil
	}

	var records []models.VulnerabilityScanRecord
	err := s.db.WithContext(ctx).
		Select("id", "scan_time", "status", "critical_count", "high_count", "medium_count", "low_count", "unknown_count", "total_count", "error").
		Where("id IN ?", imageIDs).
		Find(&records).Error

	if err != nil {
		return nil, fmt.Errorf("failed to get scan summaries: %w", err)
	}

	result := make(map[string]*vulnerability.ScanSummary, len(records))
	for _, record := range records {
		s.markStaleScanIfNeeded(ctx, &record)
		var errStr string
		if record.Error != nil {
			errStr = *record.Error
		}

		result[record.ID] = &vulnerability.ScanSummary{
			ImageID:  record.ID,
			ScanTime: record.ScanTime,
			Status:   vulnerability.ScanStatus(record.Status),
			Summary: &vulnerability.SeveritySummary{
				Critical: record.CriticalCount,
				High:     record.HighCount,
				Medium:   record.MediumCount,
				Low:      record.LowCount,
				Unknown:  record.UnknownCount,
				Total:    record.TotalCount,
			},
			Error: errStr,
		}
	}

	return result, nil
}

// ScanAllImages scans all Docker images for vulnerabilities. It is intended
// for use by the scheduled vulnerability scan job. A single long-running Trivy
// container is created and reused for every image via docker exec, which avoids
// the overhead of creating/destroying a container per scan. The caller-supplied
// user is recorded in the event log.
func (s *VulnerabilityService) ScanAllImages(ctx context.Context, envID string, user models.User) (scanned, failed int, err error) {
	dockerClient, err := s.dockerService.GetClient()
	if err != nil {
		return 0, 0, fmt.Errorf("failed to connect to Docker: %w", err)
	}

	images, err := dockerClient.ImageList(ctx, imagetypes.ListOptions{})
	if err != nil {
		return 0, 0, fmt.Errorf("failed to list images: %w", err)
	}

	trivyImage, err := s.ensureTrivyImageInternal(ctx)
	if err != nil {
		return 0, 0, fmt.Errorf("trivy scanner not available: %w", err)
	}

	cacheVolume, err := s.ensureTrivyCacheVolumeInternal(ctx)
	if err != nil {
		return 0, 0, fmt.Errorf("failed to ensure trivy cache volume: %w", err)
	}

	// Create a single long-running Trivy container for the entire batch.
	containerID, err := s.createBatchTrivyContainer(ctx, trivyImage, cacheVolume)
	if err != nil {
		return 0, 0, fmt.Errorf("failed to create batch trivy container: %w", err)
	}
	defer func() {
		cleanupCtx := context.WithoutCancel(ctx)
		if rmErr := dockerClient.ContainerRemove(cleanupCtx, containerID, containertypes.RemoveOptions{Force: true}); rmErr != nil {
			slog.WarnContext(cleanupCtx, "failed to remove batch trivy container", "containerId", containerID, "error", rmErr)
		}
	}()

	scannerVersion := s.GetTrivyVersion(ctx)

	for _, img := range images {
		if ctx.Err() != nil {
			return scanned, failed, ctx.Err()
		}

		imageID := img.ID
		imageName := imageID
		if len(img.RepoTags) > 0 {
			imageName = img.RepoTags[0]
		} else if len(img.RepoDigests) > 0 {
			imageName = img.RepoDigests[0]
		}

		// Skip intermediate / dangling images with no name
		if imageName == "<none>:<none>" || imageName == imageID {
			continue
		}

		slog.InfoContext(ctx, "scheduled vulnerability scan: scanning image", "image", imageName, "imageId", imageID)

		startTime := time.Now()
		result, scanErr := s.execTrivyScanInContainer(ctx, containerID, imageName, imageID, scannerVersion)
		duration := time.Since(startTime).Milliseconds()

		if scanErr != nil {
			failed++
			failedResult := &vulnerability.ScanResult{
				ImageID:   imageID,
				ImageName: imageName,
				ScanTime:  time.Now(),
				Status:    vulnerability.ScanStatusFailed,
				Error:     scanErr.Error(),
				Duration:  duration,
			}
			if saveErr := s.saveScanResult(ctx, failedResult); saveErr != nil {
				slog.WarnContext(ctx, "failed to save failed scan result", "error", saveErr)
			}
			s.logScheduledScanEvent(ctx, envID, imageID, imageName, user, false, scanErr.Error())
			continue
		}

		scanned++
		result.Duration = duration
		s.ensureSummary(result)
		if saveErr := s.saveScanResult(ctx, result); saveErr != nil {
			slog.WarnContext(ctx, "failed to save scan result", "error", saveErr)
		}
		s.notifyVulnerabilitiesWithFix(ctx, result)
		s.logScheduledScanEvent(ctx, envID, imageID, imageName, user, true, "")
	}

	return scanned, failed, nil
}

// createBatchTrivyContainer creates a long-running Trivy container that stays
// alive so we can exec individual scan commands into it. This avoids the
// overhead of creating/starting/removing a container for every image.
func (s *VulnerabilityService) createBatchTrivyContainer(ctx context.Context, trivyImage, cacheVolume string) (string, error) {
	dockerClient, err := s.dockerService.GetClient()
	if err != nil {
		return "", fmt.Errorf("failed to connect to Docker: %w", err)
	}

	config := &containertypes.Config{
		Image:      trivyImage,
		Entrypoint: []string{"sh", "-c", "trap 'exit 0' TERM; while :; do sleep 1; done"},
		Labels: map[string]string{
			libarcane.InternalContainerLabel: "true",
		},
	}

	hostConfig := &containertypes.HostConfig{
		Mounts: []mounttypes.Mount{
			{
				Type:   mounttypes.TypeBind,
				Source: "/var/run/docker.sock",
				Target: "/var/run/docker.sock",
			},
			{
				Type:   mounttypes.TypeVolume,
				Source: cacheVolume,
				Target: trivyCacheMountTarget,
			},
		},
		Resources: containertypes.Resources{
			NanoCPUs:   trivyMaxCPUNano,
			Memory:     trivyMaxMemoryBytes,
			MemorySwap: trivyMaxMemoryBytes,
		},
	}

	resp, err := dockerClient.ContainerCreate(ctx, config, hostConfig, nil, nil, "")
	if err != nil {
		return "", fmt.Errorf("failed to create container: %w", err)
	}

	if err := dockerClient.ContainerStart(ctx, resp.ID, containertypes.StartOptions{}); err != nil {
		_ = dockerClient.ContainerRemove(ctx, resp.ID, containertypes.RemoveOptions{Force: true})
		return "", fmt.Errorf("failed to start container: %w", err)
	}

	return resp.ID, nil
}

// execTrivyScanInContainer runs a trivy scan for a single image inside an
// already-running container via docker exec.
func (s *VulnerabilityService) execTrivyScanInContainer(ctx context.Context, containerID, imageName, imageID, scannerVersion string) (*vulnerability.ScanResult, error) {
	dockerClient, err := s.dockerService.GetClient()
	if err != nil {
		return nil, fmt.Errorf("failed to connect to Docker: %w", err)
	}

	execCfg := containertypes.ExecOptions{
		Cmd:          []string{"trivy", "image", "--format", "json", "--quiet", imageName},
		AttachStdout: true,
		AttachStderr: true,
	}

	execResp, err := dockerClient.ContainerExecCreate(ctx, containerID, execCfg)
	if err != nil {
		return nil, fmt.Errorf("failed to create exec: %w", err)
	}

	attachResp, err := dockerClient.ContainerExecAttach(ctx, execResp.ID, containertypes.ExecAttachOptions{})
	if err != nil {
		return nil, fmt.Errorf("failed to attach to exec: %w", err)
	}
	defer attachResp.Close()

	var stdout, stderr bytes.Buffer
	if _, err := stdcopy.StdCopy(&stdout, &stderr, attachResp.Reader); err != nil {
		return nil, fmt.Errorf("failed to read exec output: %w", err)
	}

	// Check exit code
	execInspect, err := dockerClient.ContainerExecInspect(ctx, execResp.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to inspect exec: %w", err)
	}

	if execInspect.ExitCode != 0 {
		errMsg := strings.TrimSpace(stderr.String())
		if errMsg == "" {
			errMsg = strings.TrimSpace(stdout.String())
		}
		if errMsg == "" {
			errMsg = fmt.Sprintf("exit status %d", execInspect.ExitCode)
		}
		return nil, fmt.Errorf("trivy scan failed: %s", errMsg)
	}

	output := bytes.TrimSpace(stdout.Bytes())
	if len(output) == 0 {
		errMsg := strings.TrimSpace(stderr.String())
		if errMsg == "" {
			errMsg = "trivy scan produced no output"
		}
		return nil, fmt.Errorf("trivy scan failed: %s", errMsg)
	}

	var trivyReport vulnerability.TrivyReport
	if err := json.Unmarshal(output, &trivyReport); err != nil {
		return nil, fmt.Errorf("failed to parse trivy output: %w", err)
	}

	result := vulnerability.ConvertTrivyReportToScanResult(&trivyReport, imageID, time.Now(), 0)
	result.ScannerVersion = scannerVersion

	return result, nil
}

// DeleteScanResult deletes the scan result for an image
func (s *VulnerabilityService) DeleteScanResult(ctx context.Context, imageID string) error {
	if s.db == nil {
		return nil
	}

	return s.db.WithContext(ctx).Where("id = ?", imageID).Delete(&models.VulnerabilityScanRecord{}).Error
}

// CleanupOrphanedScanRecords removes vulnerability scan records for images that
// no longer exist in Docker. This keeps "images scanned" counts in sync (e.g.
// avoids "5/3" when images were deleted after being scanned). Safe to call
// even when no images exist; returns the number of records deleted.
func (s *VulnerabilityService) CleanupOrphanedScanRecords(ctx context.Context) (deleted int64, err error) {
	if s.db == nil {
		return 0, nil
	}

	dockerClient, err := s.dockerService.GetClient()
	if err != nil {
		return 0, fmt.Errorf("failed to connect to Docker: %w", err)
	}

	images, err := dockerClient.ImageList(ctx, imagetypes.ListOptions{})
	if err != nil {
		return 0, fmt.Errorf("failed to list images: %w", err)
	}

	currentIDs := make(map[string]struct{}, len(images))
	for _, img := range images {
		currentIDs[img.ID] = struct{}{}
	}

	// Build list for NOT IN. If no images, we delete all scan records.
	var ids []string
	if len(currentIDs) > 0 {
		ids = make([]string, 0, len(currentIDs))
		for id := range currentIDs {
			ids = append(ids, id)
		}
	}

	var result *gorm.DB
	if len(ids) == 0 {
		result = s.db.WithContext(ctx).Where("1 = 1").Delete(&models.VulnerabilityScanRecord{})
	} else {
		result = s.db.WithContext(ctx).Where("id NOT IN ?", ids).Delete(&models.VulnerabilityScanRecord{})
	}
	if result.Error != nil {
		return 0, result.Error
	}

	return result.RowsAffected, nil
}

// GetTrivyVersion returns the Trivy version from the Trivy container image
func (s *VulnerabilityService) GetTrivyVersion(ctx context.Context) string {
	dockerClient, err := s.dockerService.GetClient()
	if err != nil {
		return ""
	}

	trivyImage, err := s.ensureTrivyImageInternal(ctx)
	if err != nil {
		return ""
	}

	config := &containertypes.Config{
		Image: trivyImage,
		Cmd:   []string{"--version"},
		Labels: map[string]string{
			libarcane.InternalContainerLabel: "true",
		},
	}

	hostConfig := &containertypes.HostConfig{
		AutoRemove: true,
	}

	resp, err := dockerClient.ContainerCreate(ctx, config, hostConfig, nil, nil, "")
	if err != nil {
		return ""
	}

	if err := dockerClient.ContainerStart(ctx, resp.ID, containertypes.StartOptions{}); err != nil {
		_ = dockerClient.ContainerRemove(ctx, resp.ID, containertypes.RemoveOptions{Force: true})
		return ""
	}

	logs, err := dockerClient.ContainerLogs(ctx, resp.ID, containertypes.LogsOptions{
		ShowStdout: true,
		ShowStderr: true,
		Follow:     true,
	})
	if err != nil {
		_ = dockerClient.ContainerRemove(ctx, resp.ID, containertypes.RemoveOptions{Force: true})
		return ""
	}
	defer logs.Close()

	var stdout bytes.Buffer
	logDone := make(chan error, 1)
	go func() {
		_, err := stdcopy.StdCopy(&stdout, io.Discard, logs)
		logDone <- err
	}()

	statusCh, errCh := dockerClient.ContainerWait(ctx, resp.ID, containertypes.WaitConditionNotRunning)
	var waitResp containertypes.WaitResponse
	select {
	case err := <-errCh:
		if err != nil {
			return ""
		}
	case waitResp = <-statusCh:
	}

	logs.Close()
	if err := <-logDone; err != nil && !errors.Is(err, io.EOF) {
		return ""
	}

	if waitResp.StatusCode != 0 {
		return ""
	}

	return parseTrivyVersion(stdout.String())
}

func parseTrivyVersion(output string) string {
	output = strings.TrimSpace(output)
	if output == "" {
		return ""
	}
	lines := strings.Split(output, "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "Version:") {
			return strings.TrimSpace(strings.TrimPrefix(line, "Version:"))
		}
	}
	return strings.TrimSpace(output)
}

func (s *VulnerabilityService) getTrivyImageRef() string {
	if s.settingsService == nil {
		return DefaultTrivyImage
	}

	cfg := s.settingsService.GetSettingsConfig()
	if cfg == nil {
		return DefaultTrivyImage
	}

	override := strings.TrimSpace(cfg.TrivyImage.Value)
	if override == "" {
		return DefaultTrivyImage
	}

	return override
}

func (s *VulnerabilityService) ensureTrivyImageInternal(ctx context.Context) (string, error) {
	dockerClient, err := s.dockerService.GetClient()
	if err != nil {
		return "", fmt.Errorf("failed to connect to Docker: %w", err)
	}

	trivyImage := s.getTrivyImageRef()
	if _, err := dockerClient.ImageInspect(ctx, trivyImage); err == nil {
		return trivyImage, nil
	}

	pullTimeoutSeconds := 0
	if s.settingsService != nil && s.settingsService.GetSettingsConfig() != nil {
		pullTimeoutSeconds = s.settingsService.GetSettingsConfig().DockerImagePullTimeout.AsInt()
	}

	pullCtx, pullCancel := timeouts.WithTimeout(ctx, pullTimeoutSeconds, timeouts.DefaultDockerImagePull)
	defer pullCancel()

	pullReader, err := dockerClient.ImagePull(pullCtx, trivyImage, imagetypes.PullOptions{})
	if err != nil {
		if errors.Is(pullCtx.Err(), context.DeadlineExceeded) {
			return "", fmt.Errorf("trivy image pull timed out for %s (increase DOCKER_IMAGE_PULL_TIMEOUT or setting)", trivyImage)
		}
		return "", fmt.Errorf("pull trivy image %s: %w", trivyImage, err)
	}
	_, _ = io.Copy(io.Discard, pullReader)
	_ = pullReader.Close()

	return trivyImage, nil
}

func (s *VulnerabilityService) ensureTrivyCacheVolumeInternal(ctx context.Context) (string, error) {
	dockerClient, err := s.dockerService.GetClient()
	if err != nil {
		return "", err
	}

	if _, err := dockerClient.VolumeInspect(ctx, trivyCacheVolumeName); err == nil {
		return trivyCacheVolumeName, nil
	}

	_, err = dockerClient.VolumeCreate(ctx, volumetypes.CreateOptions{
		Name: trivyCacheVolumeName,
		Labels: map[string]string{
			libarcane.InternalContainerLabel: "true",
		},
	})
	if err != nil {
		return "", fmt.Errorf("failed to create trivy cache volume: %w", err)
	}

	return trivyCacheVolumeName, nil
}

// runTrivyScan executes Trivy scan on an image
func (s *VulnerabilityService) getTrivyConfigFiles(ctx context.Context) (configContent, ignoreContent string, err error) {
	if s.settingsService == nil {
		return "", "", nil
	}

	cfg := s.settingsService.GetSettingsConfig()
	if cfg == nil {
		return "", "", nil
	}

	return cfg.TrivyConfig.Value, cfg.TrivyIgnore.Value, nil
}

func (s *VulnerabilityService) createTrivyConfigTempFile(ctx context.Context, content string) (string, bool) {
	configFile, err := os.CreateTemp("", "trivy-config-*.yaml")
	if err != nil {
		slog.WarnContext(ctx, "failed to create trivy config temp file", "error", err)
		return "", false
	}
	if _, err := configFile.WriteString(content); err != nil {
		slog.WarnContext(ctx, "failed to write trivy config", "error", err)
		configFile.Close()
		_ = os.Remove(configFile.Name())
		return "", false
	}
	_ = configFile.Close()
	return configFile.Name(), true
}

func (s *VulnerabilityService) createTrivyIgnoreTempFile(ctx context.Context, content string) (string, bool) {
	ignoreFile, err := os.CreateTemp("", "trivy-ignore-*")
	if err != nil {
		slog.WarnContext(ctx, "failed to create trivy ignore temp file", "error", err)
		return "", false
	}
	if _, err := ignoreFile.WriteString(content); err != nil {
		slog.WarnContext(ctx, "failed to write trivy ignore", "error", err)
		ignoreFile.Close()
		_ = os.Remove(ignoreFile.Name())
		return "", false
	}
	_ = ignoreFile.Close()
	return ignoreFile.Name(), true
}

func cleanupTempFiles(ctx context.Context, tempFiles []string) {
	for _, f := range tempFiles {
		if err := os.Remove(f); err != nil {
			slog.WarnContext(ctx, "failed to remove trivy temp file", "path", f, "error", err)
		}
	}
}

func (s *VulnerabilityService) buildTrivyCommandArgs(
	ctx context.Context,
	imageName string,
	configContent string,
	ignoreContent string,
) ([]string, []string) {
	cmdArgs := []string{"image", "--format", "json", "--quiet"}
	var tempFiles []string

	if strings.TrimSpace(configContent) != "" {
		if tempFile, ok := s.createTrivyConfigTempFile(ctx, configContent); ok {
			tempFiles = append(tempFiles, tempFile)
			cmdArgs = append(cmdArgs, "--config", "/tmp/trivy-config.yaml")
		}
	}

	if strings.TrimSpace(ignoreContent) != "" {
		if tempFile, ok := s.createTrivyIgnoreTempFile(ctx, ignoreContent); ok {
			tempFiles = append(tempFiles, tempFile)
			cmdArgs = append(cmdArgs, "--ignorefile", "/tmp/trivy-ignore")
		}
	}

	cmdArgs = append(cmdArgs, imageName)

	return cmdArgs, tempFiles
}

func buildTrivyContainerConfig(trivyImage string, cmdArgs []string) *containertypes.Config {
	return &containertypes.Config{
		Image: trivyImage,
		Cmd:   cmdArgs,
		Labels: map[string]string{
			libarcane.InternalContainerLabel: "true",
		},
	}
}

func buildTrivyHostConfig(cacheVolume string, tempFiles []string) *containertypes.HostConfig {
	hostConfig := &containertypes.HostConfig{
		AutoRemove: true,
		Mounts: []mounttypes.Mount{
			{
				Type:   mounttypes.TypeBind,
				Source: "/var/run/docker.sock",
				Target: "/var/run/docker.sock",
			},
			{
				Type:   mounttypes.TypeVolume,
				Source: cacheVolume,
				Target: trivyCacheMountTarget,
			},
		},
		Resources: containertypes.Resources{
			NanoCPUs:   trivyMaxCPUNano,
			Memory:     trivyMaxMemoryBytes,
			MemorySwap: trivyMaxMemoryBytes,
		},
	}

	addTrivyTempFileMounts(hostConfig, tempFiles)
	return hostConfig
}

func addTrivyTempFileMounts(hostConfig *containertypes.HostConfig, tempFiles []string) {
	for _, tempFile := range tempFiles {
		switch {
		case strings.Contains(tempFile, "trivy-config"):
			hostConfig.Mounts = append(hostConfig.Mounts, mounttypes.Mount{
				Type:     mounttypes.TypeBind,
				Source:   tempFile,
				Target:   "/tmp/trivy-config.yaml",
				ReadOnly: true,
			})
		case strings.Contains(tempFile, "trivy-ignore"):
			hostConfig.Mounts = append(hostConfig.Mounts, mounttypes.Mount{
				Type:     mounttypes.TypeBind,
				Source:   tempFile,
				Target:   "/tmp/trivy-ignore",
				ReadOnly: true,
			})
		}
	}
}

func (s *VulnerabilityService) runTrivyContainer(
	ctx context.Context,
	dockerClient *client.Client,
	config *containertypes.Config,
	hostConfig *containertypes.HostConfig,
) ([]byte, []byte, int64, int64, error) {
	resp, err := dockerClient.ContainerCreate(ctx, config, hostConfig, nil, nil, "")
	if err != nil {
		return nil, nil, 0, 0, fmt.Errorf("failed to create trivy container: %w", err)
	}

	if err := dockerClient.ContainerStart(ctx, resp.ID, containertypes.StartOptions{}); err != nil {
		_ = dockerClient.ContainerRemove(ctx, resp.ID, containertypes.RemoveOptions{Force: true})
		return nil, nil, 0, 0, fmt.Errorf("failed to start trivy container: %w", err)
	}

	logs, err := dockerClient.ContainerLogs(ctx, resp.ID, containertypes.LogsOptions{
		ShowStdout: true,
		ShowStderr: true,
		Follow:     true,
	})
	if err != nil {
		_ = dockerClient.ContainerRemove(ctx, resp.ID, containertypes.RemoveOptions{Force: true})
		return nil, nil, 0, 0, fmt.Errorf("failed to stream trivy logs: %w", err)
	}
	defer logs.Close()

	var stdout, stderr bytes.Buffer
	logDone := make(chan error, 1)
	go func() {
		_, err := stdcopy.StdCopy(&stdout, &stderr, logs)
		logDone <- err
	}()

	startTime := time.Now()
	statusCode, err := s.waitForTrivyContainer(ctx, dockerClient, resp.ID)
	if err != nil {
		return nil, nil, 0, 0, err
	}

	logs.Close()
	if err := <-logDone; err != nil && !errors.Is(err, io.EOF) {
		return nil, nil, 0, 0, fmt.Errorf("failed to read trivy logs: %w", err)
	}

	duration := time.Since(startTime).Milliseconds()
	return stdout.Bytes(), stderr.Bytes(), duration, statusCode, nil
}

func (s *VulnerabilityService) waitForTrivyContainer(
	ctx context.Context,
	dockerClient *client.Client,
	containerID string,
) (int64, error) {
	statusCh, errCh := dockerClient.ContainerWait(ctx, containerID, containertypes.WaitConditionNotRunning)
	select {
	case err := <-errCh:
		if err != nil {
			if ctx.Err() != nil {
				cleanupCtx, cleanupCancel := timeouts.WithTimeout(ctx, 0, timeouts.DefaultDockerAPI)
				defer cleanupCancel()
				_ = dockerClient.ContainerRemove(cleanupCtx, containerID, containertypes.RemoveOptions{Force: true})
				return 0, fmt.Errorf("scan cancelled: %w", ctx.Err())
			}
			return 0, fmt.Errorf("trivy container wait failed: %w", err)
		}
		return 0, nil
	case waitResp := <-statusCh:
		return waitResp.StatusCode, nil
	}
}

func (s *VulnerabilityService) runTrivyScan(ctx context.Context, trivyImage string, imageName string, imageID string) (*vulnerability.ScanResult, error) {
	// Use per-image locking to allow concurrent scans of different images
	lock := s.getImageLock(imageID)
	lock.Lock()
	defer lock.Unlock()

	dockerClient, err := s.dockerService.GetClient()
	if err != nil {
		return nil, fmt.Errorf("failed to connect to Docker: %w", err)
	}

	cacheVolume, err := s.ensureTrivyCacheVolumeInternal(ctx)
	if err != nil {
		return nil, err
	}

	// Get Trivy config files if they exist
	configContent, ignoreContent, err := s.getTrivyConfigFiles(ctx)
	if err != nil {
		slog.WarnContext(ctx, "failed to get trivy config files", "error", err)
	}

	cmdArgs, tempFiles := s.buildTrivyCommandArgs(ctx, imageName, configContent, ignoreContent)
	defer cleanupTempFiles(ctx, tempFiles)

	config := buildTrivyContainerConfig(trivyImage, cmdArgs)
	hostConfig := buildTrivyHostConfig(cacheVolume, tempFiles)

	stdout, stderr, duration, statusCode, err := s.runTrivyContainer(ctx, dockerClient, config, hostConfig)
	if err != nil {
		return nil, err
	}

	if statusCode != 0 {
		errMsg := strings.TrimSpace(string(stderr))
		if errMsg == "" {
			errMsg = strings.TrimSpace(string(stdout))
		}
		if errMsg == "" {
			errMsg = fmt.Sprintf("exit status %d", statusCode)
		}
		return nil, fmt.Errorf("trivy scan failed: %s", errMsg)
	}

	output := bytes.TrimSpace(stdout)
	if len(output) == 0 {
		errMsg := strings.TrimSpace(string(stderr))
		if errMsg == "" {
			errMsg = "trivy scan produced no output"
		}
		return nil, fmt.Errorf("trivy scan failed: %s", errMsg)
	}

	// Parse Trivy JSON output
	var trivyReport vulnerability.TrivyReport
	if err := json.Unmarshal(output, &trivyReport); err != nil {
		return nil, fmt.Errorf("failed to parse trivy output: %w", err)
	}

	// Convert Trivy report to our ScanResult format
	result := vulnerability.ConvertTrivyReportToScanResult(&trivyReport, imageID, time.Now(), duration)
	result.ScannerVersion = s.GetTrivyVersion(ctx)

	return result, nil
}

// saveScanResult saves the scan result to the database
func (s *VulnerabilityService) saveScanResult(ctx context.Context, result *vulnerability.ScanResult) error {
	if s.db == nil {
		return nil
	}

	s.ensureSummary(result)

	// Convert vulnerabilities to JSON
	var vulnJSON models.StringSlice
	if len(result.Vulnerabilities) > 0 {
		vulnBytes, err := json.Marshal(result.Vulnerabilities)
		if err != nil {
			return fmt.Errorf("failed to marshal vulnerabilities: %w", err)
		}
		vulnJSON = models.StringSlice{string(vulnBytes)}
	}

	var errPtr *string
	if result.Error != "" {
		errPtr = &result.Error
	}

	var summary *vulnerability.SeveritySummary
	if result.Summary != nil {
		summary = result.Summary
	} else {
		summary = &vulnerability.SeveritySummary{}
	}

	record := models.VulnerabilityScanRecord{
		ID:              result.ImageID,
		ImageName:       result.ImageName,
		Status:          string(result.Status),
		ScanTime:        result.ScanTime,
		Duration:        result.Duration,
		CriticalCount:   summary.Critical,
		HighCount:       summary.High,
		MediumCount:     summary.Medium,
		LowCount:        summary.Low,
		UnknownCount:    summary.Unknown,
		TotalCount:      summary.Total,
		Vulnerabilities: vulnJSON,
		Error:           errPtr,
		ScannerVersion:  result.ScannerVersion,
	}

	// Upsert the record
	return s.db.WithContext(ctx).Clauses(clause.OnConflict{
		Columns:   []clause.Column{{Name: "id"}},
		UpdateAll: true,
	}).Create(&record).Error
}

const nvdBaseURL = "https://nvd.nist.gov/vuln/detail/"

func cveLink(vulnerabilityID string) string {
	if vulnerabilityID == "" {
		return ""
	}
	if strings.HasPrefix(strings.ToUpper(vulnerabilityID), "CVE-") {
		return nvdBaseURL + vulnerabilityID
	}
	return ""
}

// notifyVulnerabilitiesWithFix sends a notification for each vulnerability that has a fixed version.
// It is called after a successful scan save. Notifications are sent asynchronously; errors are logged.
// Notifications are suppressed for ignored vulnerabilities across all environments.
func (s *VulnerabilityService) notifyVulnerabilitiesWithFix(ctx context.Context, result *vulnerability.ScanResult) {
	if s.notificationService == nil || result == nil {
		return
	}
	if result.Status != vulnerability.ScanStatusCompleted || len(result.Vulnerabilities) == 0 {
		return
	}

	vulnerabilities := result.Vulnerabilities
	filtered, err := s.filterIgnoredVulnerabilitiesForImage(ctx, result.ImageID, vulnerabilities)
	if err != nil {
		slog.WarnContext(ctx, "failed to filter ignored vulnerabilities for notifications", "error", err)
	} else {
		vulnerabilities = filtered
	}

	for i := range vulnerabilities {
		v := &vulnerabilities[i]
		if v.FixedVersion == "" {
			continue
		}
		payload := VulnerabilityNotificationPayload{
			CVEID:            v.VulnerabilityID,
			CVELink:          cveLink(v.VulnerabilityID),
			Severity:         string(v.Severity),
			ImageName:        result.ImageName,
			FixedVersion:     v.FixedVersion,
			PkgName:          v.PkgName,
			InstalledVersion: v.InstalledVersion,
		}
		if err := s.notificationService.SendVulnerabilityNotification(ctx, payload); err != nil {
			slog.WarnContext(ctx, "failed to send vulnerability notification", "cve", v.VulnerabilityID, "image", result.ImageName, "error", err)
		}
	}
}

func (s *VulnerabilityService) filterIgnoredVulnerabilitiesForImage(
	ctx context.Context,
	imageID string,
	vulns []vulnerability.Vulnerability,
) ([]vulnerability.Vulnerability, error) {
	if s.db == nil || len(vulns) == 0 || imageID == "" {
		return vulns, nil
	}

	var ignores []models.VulnerabilityIgnore
	if err := s.db.WithContext(ctx).Where("image_id = ?", imageID).Find(&ignores).Error; err != nil {
		return nil, err
	}
	if len(ignores) == 0 {
		return vulns, nil
	}

	ignoredKeys := make(map[string]struct{}, len(ignores))
	for _, ignore := range ignores {
		key := fmt.Sprintf("%s:%s:%s:%s", ignore.ImageID, ignore.VulnerabilityID, ignore.PkgName, ignore.InstalledVersion)
		ignoredKeys[key] = struct{}{}
	}

	filtered := make([]vulnerability.Vulnerability, 0, len(vulns))
	for _, vuln := range vulns {
		key := fmt.Sprintf("%s:%s:%s:%s", imageID, vuln.VulnerabilityID, vuln.PkgName, vuln.InstalledVersion)
		if _, isIgnored := ignoredKeys[key]; isIgnored {
			continue
		}
		filtered = append(filtered, vuln)
	}

	return filtered, nil
}

// convertRecordToResult converts a database record to a ScanResult
func (s *VulnerabilityService) convertRecordToResult(record *models.VulnerabilityScanRecord) (*vulnerability.ScanResult, error) {
	result := &vulnerability.ScanResult{
		ImageID:   record.ID,
		ImageName: record.ImageName,
		ScanTime:  record.ScanTime,
		Status:    vulnerability.ScanStatus(record.Status),
		Duration:  record.Duration,
		Summary: &vulnerability.SeveritySummary{
			Critical: record.CriticalCount,
			High:     record.HighCount,
			Medium:   record.MediumCount,
			Low:      record.LowCount,
			Unknown:  record.UnknownCount,
			Total:    record.TotalCount,
		},
		ScannerVersion: record.ScannerVersion,
	}

	if record.Error != nil {
		result.Error = *record.Error
	}

	// Parse vulnerabilities from JSON
	if len(record.Vulnerabilities) > 0 && record.Vulnerabilities[0] != "" {
		var vulns []vulnerability.Vulnerability
		if err := json.Unmarshal([]byte(record.Vulnerabilities[0]), &vulns); err != nil {
			slog.Warn("failed to unmarshal vulnerabilities", "error", err)
		} else {
			result.Vulnerabilities = vulns
		}
	}

	s.ensureSummary(result)

	return result, nil
}

func (s *VulnerabilityService) ensureSummary(result *vulnerability.ScanResult) {
	if result == nil {
		return
	}

	if len(result.Vulnerabilities) == 0 {
		if result.Summary == nil {
			result.Summary = &vulnerability.SeveritySummary{}
		}
		return
	}

	if result.Summary != nil && result.Summary.Total > 0 {
		return
	}

	result.Summary = buildSeveritySummaryFromVulnerabilitiesInternal(result.Vulnerabilities)
}

func buildSeveritySummaryFromVulnerabilitiesInternal(vulns []vulnerability.Vulnerability) *vulnerability.SeveritySummary {
	summary := &vulnerability.SeveritySummary{}
	for _, vuln := range vulns {
		switch vuln.Severity {
		case vulnerability.SeverityCritical:
			summary.Critical++
		case vulnerability.SeverityHigh:
			summary.High++
		case vulnerability.SeverityMedium:
			summary.Medium++
		case vulnerability.SeverityLow:
			summary.Low++
		case vulnerability.SeverityUnknown:
			summary.Unknown++
		default:
			summary.Unknown++
		}
		summary.Total++
	}
	return summary
}

// logScanEvent logs a vulnerability scan event
func (s *VulnerabilityService) logScanEvent(ctx context.Context, envID string, imageID, imageName string, user models.User, success bool, errMsg string) {
	metadata := models.JSON{
		"action":    "vulnerability_scan",
		"imageId":   imageID,
		"imageName": imageName,
		"success":   success,
	}
	if errMsg != "" {
		metadata["error"] = errMsg
	}

	environmentID := envID
	if environmentID == "" {
		environmentID = "0"
	}

	eventType := models.EventTypeImageScan
	if err := s.eventService.LogImageEvent(ctx, eventType, imageID, imageName, user.ID, user.Username, environmentID, metadata); err != nil {
		slog.WarnContext(ctx, "failed to log vulnerability scan event", "error", err)
	}
}

// logScheduledScanEvent logs a vulnerability scan event using the dedicated scheduled scan event type.
func (s *VulnerabilityService) logScheduledScanEvent(ctx context.Context, envID string, imageID, imageName string, user models.User, success bool, errMsg string) {
	metadata := models.JSON{
		"action":    "scheduled_vulnerability_scan",
		"imageId":   imageID,
		"imageName": imageName,
		"success":   success,
	}
	if errMsg != "" {
		metadata["error"] = errMsg
	}

	environmentID := envID
	if environmentID == "" {
		environmentID = "0"
	}

	if err := s.eventService.LogImageEvent(ctx, models.EventTypeImageVulnerabilityScan, imageID, imageName, user.ID, user.Username, environmentID, metadata); err != nil {
		slog.WarnContext(ctx, "failed to log scheduled vulnerability scan event", "error", err)
	}
}

// stringPtrValueOrEmptyInternal returns the string value from a pointer or empty string if nil
func stringPtrValueOrEmptyInternal(p *string) string {
	if p == nil {
		return ""
	}
	return *p
}

// IgnoreVulnerability creates a new ignore record for a vulnerability
func (s *VulnerabilityService) IgnoreVulnerability(ctx context.Context, envID string, payload *vulnerability.IgnorePayload) (*models.VulnerabilityIgnore, error) {
	if s.db == nil {
		return nil, errors.New("database not available")
	}

	// Check if already ignored (composite key check)
	var existing models.VulnerabilityIgnore
	err := s.db.WithContext(ctx).Where(
		"environment_id = ? AND image_id = ? AND vulnerability_id = ? AND pkg_name = ? AND installed_version = ?",
		envID, payload.ImageID, payload.VulnerabilityID, payload.PkgName, payload.InstalledVersion,
	).First(&existing).Error

	if err == nil {
		return nil, errors.New("vulnerability is already ignored")
	}

	if !errors.Is(err, gorm.ErrRecordNotFound) {
		return nil, fmt.Errorf("failed to check existing ignore: %w", err)
	}

	ignore := &models.VulnerabilityIgnore{
		EnvironmentID:    envID,
		ImageID:          payload.ImageID,
		VulnerabilityID:  payload.VulnerabilityID,
		PkgName:          payload.PkgName,
		InstalledVersion: payload.InstalledVersion,
		Reason:           payload.Reason,
		CreatedBy:        payload.CreatedBy,
	}

	if err := s.db.WithContext(ctx).Create(ignore).Error; err != nil {
		return nil, fmt.Errorf("failed to create ignore record: %w", err)
	}

	slog.InfoContext(ctx, "vulnerability ignored",
		"vulnerability_id", payload.VulnerabilityID,
		"image_id", payload.ImageID,
		"pkg_name", payload.PkgName,
	)

	return ignore, nil
}

// UnignoreVulnerability removes an ignore record
func (s *VulnerabilityService) UnignoreVulnerability(ctx context.Context, envID string, ignoreID string) error {
	if s.db == nil {
		return errors.New("database not available")
	}

	result := s.db.WithContext(ctx).Where("id = ? AND environment_id = ?", ignoreID, envID).Delete(&models.VulnerabilityIgnore{})
	if result.Error != nil {
		return fmt.Errorf("failed to delete ignore record: %w", result.Error)
	}

	if result.RowsAffected == 0 {
		return errors.New("ignore record not found")
	}

	slog.InfoContext(ctx, "vulnerability unignored", "ignore_id", ignoreID)
	return nil
}

func applyIgnoredVulnerabilitiesSort(query *gorm.DB, sort string) *gorm.DB {
	if sort == "" {
		return query.Order("created_at DESC")
	}

	for _, part := range strings.Split(sort, ",") {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}

		desc := false
		switch {
		case strings.HasPrefix(part, "-"):
			desc = true
			part = strings.TrimPrefix(part, "-")
		case strings.HasPrefix(part, "+"):
			part = strings.TrimPrefix(part, "+")
		}

		query = applyIgnoredVulnerabilitiesSortPart(query, part, desc)
	}

	return query
}

func applyIgnoredVulnerabilitiesSortPart(query *gorm.DB, part string, desc bool) *gorm.DB {
	direction := "ASC"
	if desc {
		direction = "DESC"
	}

	switch part {
	case "createdAt":
		return query.Order("created_at " + direction)
	case "vulnerabilityId":
		return query.Order("vulnerability_id " + direction)
	default:
		return query.Order("created_at DESC")
	}
}

func mapIgnoredVulnerabilities(ignores []models.VulnerabilityIgnore) []vulnerability.IgnoredVulnerability {
	result := make([]vulnerability.IgnoredVulnerability, len(ignores))
	for i, ignore := range ignores {
		result[i] = vulnerability.IgnoredVulnerability{
			ID:               ignore.ID,
			EnvironmentID:    ignore.EnvironmentID,
			ImageID:          ignore.ImageID,
			VulnerabilityID:  ignore.VulnerabilityID,
			PkgName:          ignore.PkgName,
			InstalledVersion: ignore.InstalledVersion,
			Reason:           ignore.Reason,
			CreatedBy:        ignore.CreatedBy,
			CreatedAt:        ignore.CreatedAt,
		}
	}
	return result
}

func buildIgnoredVulnerabilitiesResponse(total int64, params pagination.QueryParams, ignores []models.VulnerabilityIgnore) pagination.Response {
	filtered := pagination.FilterResult[models.VulnerabilityIgnore]{
		Items:          ignores,
		TotalCount:     total,
		TotalAvailable: total,
	}
	return pagination.BuildResponseFromFilterResult(filtered, params)
}

// ListIgnoredVulnerabilities returns a list of ignored vulnerabilities for an environment
func (s *VulnerabilityService) ListIgnoredVulnerabilities(ctx context.Context, envID string, params pagination.QueryParams) ([]vulnerability.IgnoredVulnerability, pagination.Response, error) {
	if params.Limit == 0 {
		params.Limit = 20
	}

	if s.db == nil {
		return []vulnerability.IgnoredVulnerability{}, pagination.Response{
			TotalPages:      1,
			TotalItems:      0,
			CurrentPage:     1,
			ItemsPerPage:    params.Limit,
			GrandTotalItems: 0,
		}, nil
	}

	var ignores []models.VulnerabilityIgnore
	query := s.db.WithContext(ctx).Where("environment_id = ?", envID)
	query = applyIgnoredVulnerabilitiesSort(query, params.Sort)

	// Count total
	var total int64
	if err := query.Model(&models.VulnerabilityIgnore{}).Count(&total).Error; err != nil {
		return nil, pagination.Response{}, fmt.Errorf("failed to count ignored vulnerabilities: %w", err)
	}

	// Apply pagination
	offset := params.Start
	if err := query.Offset(offset).Limit(params.Limit).Find(&ignores).Error; err != nil {
		return nil, pagination.Response{}, fmt.Errorf("failed to list ignored vulnerabilities: %w", err)
	}

	result := mapIgnoredVulnerabilities(ignores)
	response := buildIgnoredVulnerabilitiesResponse(total, params, ignores)

	return result, response, nil
}

// GetIgnoreRecordsForImage retrieves all ignore records for a specific image
func (s *VulnerabilityService) GetIgnoreRecordsForImage(ctx context.Context, envID string, imageID string) ([]models.VulnerabilityIgnore, error) {
	if s.db == nil {
		return nil, nil
	}

	var ignores []models.VulnerabilityIgnore
	if err := s.db.WithContext(ctx).Where("environment_id = ? AND image_id = ?", envID, imageID).Find(&ignores).Error; err != nil {
		return nil, fmt.Errorf("failed to get ignore records: %w", err)
	}

	return ignores, nil
}

// filterIgnoredVulnerabilities removes ignored vulnerabilities from the list
func (s *VulnerabilityService) filterIgnoredVulnerabilities(ctx context.Context, envID string, vulns []vulnerability.VulnerabilityWithImage) ([]vulnerability.VulnerabilityWithImage, error) {
	if s.db == nil || len(vulns) == 0 {
		return vulns, nil
	}

	// Get all ignore records for this environment
	var ignores []models.VulnerabilityIgnore
	if err := s.db.WithContext(ctx).Where("environment_id = ?", envID).Find(&ignores).Error; err != nil {
		return nil, fmt.Errorf("failed to get ignore records: %w", err)
	}

	if len(ignores) == 0 {
		return vulns, nil
	}

	// Build a set of ignored vulnerability keys
	ignoredKeys := make(map[string]struct{}, len(ignores))
	for _, ignore := range ignores {
		key := fmt.Sprintf("%s:%s:%s:%s", ignore.ImageID, ignore.VulnerabilityID, ignore.PkgName, ignore.InstalledVersion)
		ignoredKeys[key] = struct{}{}
	}

	// Filter out ignored vulnerabilities
	filtered := make([]vulnerability.VulnerabilityWithImage, 0, len(vulns))
	for _, vuln := range vulns {
		key := fmt.Sprintf("%s:%s:%s:%s", vuln.ImageID, vuln.VulnerabilityID, vuln.PkgName, vuln.InstalledVersion)
		if _, isIgnored := ignoredKeys[key]; !isIgnored {
			filtered = append(filtered, vuln)
		}
	}

	return filtered, nil
}
